---
title: 有栈协程和无栈协程
date: 2025-11-25 16:47:54
tags: [协程]
---
# 无栈协程为什么只是栈“更小更灵活”？

---
### 1. 传统“有栈”协程/线程
我们先看看传统的“有栈”模型是什么样的。
*   **内存模型**：每个线程或协程都拥有一个**独立的、连续的、固定大小**的内存块作为它的栈。
*   **工作方式**：当你调用一个函数时，一个新的“栈帧”会被 `push` 到这个栈的顶部，用于存储局部变量、返回地址等。函数返回时，这个栈帧被 `pop` 出来。这就像一叠盘子，只能在最上面放或取。
*   **问题**：
    *   **大小固定**：你必须为每个协程预先分配一个栈空间（比如 512KB 或 1MB）。这个大小很难权衡：
        *   **太小了**：如果函数调用层次很深，就会发生“栈溢出”。
        *   **太大了**：即使协程只用了很少的栈（比如只有几 KB），剩下的空间也会被浪费掉。
    *   **内存消耗巨大**：当你想创建成千上万甚至上百万个并发协程时，每个协程都带着一个几百 KB 的栈，总内存消耗会变得非常惊人，根本无法扩展。
---
### 2. “无栈”协程
现在我们来看“无栈”协程是如何解决这个问题的。它并不是真的“没有栈”，而是**没有传统意义上那个连续的、固定大小的栈**。
*   **内存模型**：协程的执行状态（也就是传统栈里存的东西）被**拆分并保存到堆上分配的独立对象中**。
*   **工作方式（编译器的魔法）**：
    1.  **状态机转换**：当你写一个包含 `await`（在异步编程中）或 `yield`（在生成器中）的函数时，编译器会悄悄地把这个函数重写成一个**状态机**。
    2.  **变量“提升”**：函数中所有在 `await`/`yield` 点之后还需要用到的局部变量，都会被编译器“捕获”，并打包成一个结构体（或称为“闭包”、“帧对象”），这个结构体在**堆上**分配内存。
    3.  **暂停点即状态**：每次执行到 `await`/`yield`，协程就会“暂停”。此时，它会把自己的当前状态（比如“我刚执行完第 3 步，正要进入第 4 步”）和所有需要的局部变量都保存在那个堆上的对象里。然后，控制权交还给调度器，CPU 可以去执行其他协程。
    4.  **恢复执行**：当调度器决定恢复这个协程时，它会找到那个堆上的对象，读取保存的状态，然后直接跳转到上次暂停的地方继续执行。
---
### 3. 对比你的理解：“更小更灵活”
现在我们来看看为什么你的描述“更小更灵活”是如此贴切。
#### **更小**
*   **按需分配**：传统协程不管实际需要多少，都先占着一个大块内存（比如 512KB）。而无栈协程只为**真正用到的局部变量**分配内存。如果一个函数在暂停点只需要 3 个 `int` 变量，那它可能就只分配 12 个字节加上一点点对象头开销。
*   **极致的并发**：因为每个协程的内存开销极小（可能只有几十到几百字节），你就可以在单台机器上轻松创建**百万级别**的并发协程，而内存压力很小。这是现代高并发网络编程（如 Node.js, Go, Rust 的 async/await）的基石。
#### **更灵活**
*   **动态增长**：传统栈的大小是固定的，无法动态调整。而无栈协程的“栈”是由一系列堆上对象组成的，它可以随着函数调用和暂停点的增加而“动态增长”，没有固定大小的限制。
*   **生命周期独立**：堆上分配的对象的生命周期由协程的执行状态决定，而不是由某个线程的生命周期决定。这使得协程可以被任意调度到不同的线程上执行，而不用担心栈归属问题。
---
### 总结与类比
| 特性 | 有栈协程/线程 | 无栈协程 |
| :--- | :--- | :--- |
| **内存模型** | 连续的、固定大小的栈块 | 分散的、堆上分配的对象 |
| **大小** | 预先分配，较大 (KB-MB) | 按需分配，极小 (几十-几百字节) |
| **灵活性** | 差，大小固定，易溢出或浪费 | 极高，动态增长，无溢出风险 |
| **实现** | 依赖操作系统或运行时的栈指针 | 依赖编译器将函数重写为状态机 |
| **适用场景** | 线程、绿色线程（如 Go 的早期模型） | 现代异步编程（async/await）、生成器 |
**一个简单的类比：**
*   **有栈协程**：就像给每个工人一个**固定大小的工具箱**。不管他今天修螺丝还是造汽车，都得拖着这个大箱子，里面大部分工具可能都用不上，但又不能不带。
*   **无栈协程**：就像给工人一个**智能手环**。当他需要某个工具时，他对手环说一声，系统就从中央仓库（堆）里把那个工具（局部变量）送到他手上。工作暂停时，工具自动归还。他身上只带一个轻便的手环（状态对象）。
所以，你的结论完全正确。**“无栈”协程是一种更高级、更节省内存的“栈”实现方式，它通过将栈数据从连续内存块转移到堆上的离散对象，实现了极致的轻量化和灵活性。** 它不是消灭了栈，而是“解构”了栈。

