---
title: 协程库关键字使用
date: 2025-11-25 16:58:00
tags: [协程]
top: 1
---
# co_await、co_yield、co_return、co_spawn、co_sleep用法

好的，这是一个非常棒的总结性问题！这些关键字和函数是协程编程的基石。我们来逐一分解，并明确区分哪些是 C++20 语言标准的一部分，哪些是库提供的功能。
---
### C++20 标准协程关键字
这三个是 C++20 语言本身定义的关键字，是构成协程语法的核心。
#### 1. `co_await`：等待与挂起
*   **类型**：C++20 **关键字**
*   **核心作用**：**挂起当前协程，等待一个异步操作完成**。当操作完成后，协程会从挂起点恢复执行。
*   **使用场景**：当你的协程需要执行一个耗时的操作，如网络 I/O、文件读写、定时器等待等，你不想阻塞线程时，就使用它。
*   **绝佳比喻**：你（协程）把衣服放进洗衣机（异步操作），然后按下启动键（`co_await`）。你不会站在洗衣机前傻等，而是转身去看电视（线程去执行其他协程）。洗衣机洗完后（操作完成），它会“叮”一声通知你，你再回来把衣服拿出来（协程恢复）。
*   **代码示例 (Boost.Asio)**：
    ```cpp
    // 等待1秒，期间线程可以做其他事
    boost::asio::steady_timer timer(ctx, std::chrono::seconds(1));
    co_await timer.async_wait(boost::asio::use_awaitable); 
    std::cout << "1秒已过" << std::endl;
    ```
#### 2. `co_yield`：产出与暂停
*   **类型**：C++20 **关键字**
*   **核心作用**：**从协程中返回一个值，但协程并不结束，而是暂停**。下次被调用时，协程会从暂停点继续执行。
*   **使用场景**：主要用于实现**生成器**。当你需要从一个函数中分批、多次地产生数据序列时，它比返回一个完整的容器更节省内存。
*   **绝佳比喻**：一个流水线上的工人（协程）。他做好一个零件（`co_yield part`），就把零件递出去，然后继续做下一个。他不会做完所有零件再一次性交货。
*   **代码示例 (概念性)**：
    ```cpp
    // 生成斐波那契数列的生成器
    Generator<int> fibonacci() {
        int a = 0, b = 1;
        while (true) {
            co_yield a; // 返回 a，然后暂停
            int tmp = a + b;
            a = b;
            b = tmp;
        }
    }
    ```
#### 3. `co_return`：结束与返回
*   **类型**：C++20 **关键字**
*   **核心作用**：**结束当前协程的执行，并可以返回一个最终结果**。它标志着协程生命周期的终结。
*   **使用场景**：当协程完成了它的所有任务，需要返回一个最终的计算结果或状态时。
*   **绝佳比喻**：厨师（协程）做完最后一道菜，把它端上桌，然后宣布“今天收工了”（`co_return`）。
*   **代码示例**：
    ```cpp
    boost::asio::awaitable<int> compute_answer() {
        // ... 经过一系列复杂的异步计算 ...
        co_return 42; // 协程结束，返回最终答案 42
    }
    ```
---
### 协程库提供的函数/概念
这些不是 C++20 标准的一部分，而是由流行的协程库（如 Boost.Asio）提供的便利函数，极大地简化了协程的使用。
#### 4. `co_spawn`：启动与调度
*   **类型**：**函数** (最著名的是 Boost.Asio 中的函数)
*   **核心作用**：**创建并启动一个新的协程任务**，将其提交给 I/O 上下文（事件循环）去调度执行。
*   **使用场景**：当你有一个任务（通常是一个 lambda 或返回 `awaitable` 的函数），想让它“在后台”作为一个协程跑起来时。
*   **绝佳比喻**：餐厅经理（主程序）看到菜单上来了新订单（一个任务），他用 `co_spawn` 把这个任务**分配**给一个空闲的厨师（启动一个新协程）。
*   **代码示例 (Boost.Asio)**：
    ```cpp
    // 启动一个后台协程来处理连接，不关心其结果
    co_spawn(ctx, handle_connection(std::move(socket)), boost::asio::detached);
    ```
#### 5. `co_sleep`：协程式睡眠
*   **类型**：**库函数/概念** (并非所有库都有，但很常见)
*   **核心作用**：**让当前协程暂停指定的时间**。这是一个语法糖，其底层实现通常是创建一个定时器并 `co_await` 它。
*   **使用场景**：需要延迟执行某些操作，或者实现心跳、定时任务等。
*   **绝佳比喻**：你（协程）想午睡5分钟。你设了个闹钟（`co_sleep`），然后就去睡了。闹钟响后，你醒来继续工作。这期间，你的身体（线程）可能被拿去干别了。
*   **代码示例 (概念性)**：
    ```cpp
    // 很多库会提供这样的便利函数
    co_sleep(5); // 暂停5秒
    // 在 Boost.Asio 中，它的等价实现是：
    boost::asio::steady_timer timer(ctx, std::chrono::seconds(5));
    co_await timer.async_wait(boost::asio::use_awaitable);
    ```
---
### 总结与关系图谱
| 关键字/函数 | 类型 | 核心作用 | 比喻 |
| :--- | :--- | :--- | :--- |
| **`co_await`** | C++20 关键字 | **等待**，挂起协程 | 等洗衣机洗完 |
| **`co_yield`** | C++20 关键字 | **产出**，暂停并返回值 | 流水线递出零件 |
| **`co_return`** | C++20 关键字 | **结束**，返回最终结果 | 厨师宣布收工 |
| **`co_spawn`** | 库函数 | **启动**，创建新协程 | 经理分配任务 |
| **`co_sleep`** | 库函数/概念 | **睡眠**，暂停指定时间 | 设闹钟午睡 |
**它们如何协同工作？**
一个典型的协程应用流程是这样的：
1.  在 `main` 函数中，使用 **`co_spawn`** 启动一个顶层协程。
2.  在这个协程（或它启动的其他协程）内部，使用 **`co_await`** 来等待各种异步 I/O 或定时器（可能封装在 **`co_sleep`** 中）。
3.  如果这个协程是一个生成器，它会使用 **`co_yield`** 来多次产生数据。
4.  当任务全部完成，协程使用 **`co_return`** 来结束自己的生命并返回结果。
记住这个分类：**`co_await`, `co_yield`, `co_return` 是协程的“动词”，定义了协程内部的行为；而 `co_spawn` 是启动协程的“动词”，定义了协程如何被创建和管理。**

